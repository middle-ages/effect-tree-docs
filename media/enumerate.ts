import {branch, of, type Branch, type Tree} from '#tree'
import {Number} from '#util'
import {square} from '#util/Pair'
import {Array, pipe} from 'effect'
import type {NonEmptyArray} from 'effect/Array'
import {decode} from './decoder.js'
import {encode} from './encoder.js'

/**
 * How many labeled trees of `n` nodes are there?
 *
 * https://en.wikipedia.org/wiki/Cayley%27s_formula
 * @category codec
 */
export const labeledTreeCount = (n: number): number => n ** (n - 2)

/**
 * How many nodes in the tree generated by the given prüfer code?
 * @category codec
 */
export const computeNodeCount = (code: number[]) => code.length + 2,
  /** What is element count of the prüfer code for the given node count? */
  codeCount = (nodeCount: number) => nodeCount - 2

/**
 * returns the prüfer sequence for the `nₜₕ` labeled tree with a node
 * count of `nodeCount`. Note the `n` is an ordinal that starts at `1`.
 * @category codec
 */
export const fromOrdinal = (n: number, nodeCount: number): number[] => {
  if (nodeCount < 3) {
    return []
  }

  const digits = Array.map(Number.toRadix(n - 1, nodeCount), Number.increment),
    padN = nodeCount - digits.length - 2

  return pipe(
    digits,
    Array.prependAll(padN === 0 ? [] : Array.replicate(1, padN)),
  )
}

/**
 * Get the node count and index of the given prüfer code. This is the opposite of
 * `ordinalToPrüfer` in that composing one of each in any order is identity.
 * Returns a pair of node count and ordinal, where the ordinal is always smaller
 * than the node count.
 * @category codec
 */
export const toOrdinal: (
  code: number[],
) => [ordinal: number, nodeCount: number] = code => {
  if (!Array.isNonEmptyArray(code)) {
    return [2, 1]
  }

  const [lessOne, nodeCount] = pipe(
    code,
    Array.map(Number.decrement),
    square.mapSecond(computeNodeCount),
  )

  return [Number.fromRadix(lessOne, nodeCount) + 1, nodeCount]
}

/**
 * Get the `nₜₕ` labeled numeric tree for the given node count.
 * @category codec
 */
export const getNthTree = (ordinal: number, nodeCount: number): Tree<number> =>
  pipe(fromOrdinal(ordinal, nodeCount), decode)

/**
 * In the ordered set of trees with N labeled nodes, a set where the given tree
 * is very much a member of, what is the ordinal number of the given tree in the
 * set? Returns a numeric pair of ordinal and node tree count.
 * @category codec
 */
export const treeToOrdinal: (
  self: Branch<number>,
) => [ordinal: number, nodeCount: number] = branch =>
  pipe(branch, encode(Number.Order), toOrdinal)

/**
 * A list of all codes for the given node count.
 * @category codec
 */
export const allCodesAt = (nodeCount: number): NonEmptyArray<number[]> =>
  pipe(
    Array.range(1, labeledTreeCount(nodeCount)),
    Array.map(n => fromOrdinal(n, nodeCount)),
  )

/**
 * A list of all possible trees for the given node count.
 * @category codec
 */
export const allTreesAt = (nodeCount: number): Tree<number>[] =>
  nodeCount < 2
    ? []
    : nodeCount === 2
      ? [branch(1, [of(2)])]
      : pipe(nodeCount, allCodesAt, Array.map(decode))
